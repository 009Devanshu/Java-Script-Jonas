>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Activating Strict Mode<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

>Strict mode is a special mode that we can activate in javascript which makes easier for us to write a secure javascript code. All we have to do to activate strict mode. Write this at the beginning of script-->
 'use strict';		(AT the beginning of script)
 
> We can also activate strict mode only for a specific function or specific block.
 
> Strict mode makes it easier for developers to avoid accidental erros, so basically it helps us introduce bugs in our code. That is because of two reasons, first strict mode forbids us to do certain things and second, it will actually create visible errors for us in certain situations in which without strict mode JS would simply fail silectly without letting us know that we did a mistake. 

Example:-
--------------
let hasDriversLicense = false;
const passTest = true;
if (passTest) hasDriverLicense = true;
if (hasDriversLicense) console.log("I can drive:D");

When we will see on console, we will not get any output and also it will inform us about any error in console.
We got an error:-
Uncaught ReferenceError: assignment to undeclared variable hasDriverLicense


Example2:-
----------------
const interface = "Audio";
Uncaught SyntaxError: interface is a reserved identifier

	That means JS is reserving the word interface for a feature that it might implement in the future. 

Example3:-
const private = 534;	(It will not work)

	If we don't use strict mode, these variable names will work and give output on the consoe without giving any error. 
	

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Functions<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

> Defining function-->
function logger(){
	console.log('My name is Jonas');
}

logger();	This process of using the function is called invoking the function, running the function or calling the function.
logger();
logger();
We can call it multiple times. 

> We can pass a value to function and a function can return a value as well. 

function fruiteProcessor(apples,oranges){		//apples and oranges will be defined once the function is called.
	console.log(apples,oranges);
	const juice = `juice with ${apples} apples and ${oranges} oranges.`;
	return juice;
}

const appleJuice = fruitProcessor(5, 0);
console.log(appleJuice);
console.log(fruitProcessor(5, 4));

> In the first example
  function logger(){
	console.log('My name is Jonas');
  }
  
  what if we pass an argument-->
  logger(23);
  output: My name is Devanshu.
  
  It means, no effect of passing arguments. 


>console.log(fruiteProcessor(5,0));
	log is also a function.
	
 Number('23') is also a function which returns 23. 


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Function Declarations VS Expressions<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


>Function Declaration

 function calcAge1(birthYear){
 	return 2037-birthYear;
 }
 
 const age1 = calcAge1(1991);
 
>Function Expression
 const calcAge2 = function (birthYear) {			//Right hand part is a function without name. So, it is also called anonymous function.
  return 2037 - birthYear;					//Variable on the left hand side represents the function
};
const age2 = calcAge2(1991);

Another Example
const age3 = function (birthYear) {
  console.log("The age is " + birthYear);
};
const age4 = age3(1956);


> We can call a function declaration before they are defined in the code but we can't do it with function expression
const age1 = calcAge1(1991);
console.log(age1);
function calcAge1(birthYear) {
  return 2037 - birthYear;
}



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Arrow Functions<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Arrow function is a special case of function expression that is shorter and therefore faster to write. 

//Arrow Function
birthYear=>2037-birthYear;	

To use this arrow function-->
const calcAge3 = (birthYear) => 2037 - birthYear;
const age3 = calcAge3(1991);
console.log(age3);

>But, arrow function becomes more comples when add more parameters or more code

const yearsUntilRetirement = birthYear=>{
	const age=2037-birthYear;
	const retirement=65-age;
	return retirement;
}

console.log(yearsUntilRetirement(1991));


const yearsUntilRetirement = (birthYear,firstName)=>{
	const age=2037-birthYear;
	const retirement=65-age;
	return `${firstName} retires in ${retirement} years`;
}
console.log(yearsUntilRetirement(1991, "Devanshu"));

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Function Calling Another Functions<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



function cutFruitPieces(fruit) {
  return fruit * 4;
}
function fruitProcessor(apples, oranges) {
  const applePieces = cutFruitPieces(apples);
  const orangePieces = cutFruitPieces(oranges);

  const juice = `Juice with ${applePieces} apples and ${orangePieces} oranges`;
  return juice;
}
console.log(fruitProcessor(2, 3));

> const cutPieces = function (fruit) {
  return fruit * 4;
};
const fruitProcessor = function (apples, oranges) {
  const applePieces = cutPieces(4);
  const orangePieces = cutPieces(5);
  const juice = `juice with ${applePieces} pieces of apple and ${orangePieces} pieces of `;
  return juice;
};


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Reviewing Functions<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const calcAge = function (birthYear) {
  return 2037 - birthYear;
};
const yearsUntilRetirement = function (birthYear, firstName) {
  const age = calcAge(birthYear);
  const retirement = 65 - age;
  if (retirement > 0) {
    console.log(`${firstName} retires in ${retirement} years`);
    return retirement;
    //console.log(`It will not be executed`);		This line will give error because it can not be executed.
  } else {
    console.log(`${firstName} has already retired`);
    return -1;
  }
};


//console.log(`It will not be executed`);	This line will not be executed because whenever control statement encounters with return statement, it moves out of the function.



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Reviewing Functions<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

>Two ways to use Arrays:-
1)const friends = ["Micheal", "Steven", "Peter"];
  console.log(friends);
  Output:-[ "Micheal", "Steven", "Peter" ]

2)const years = new Array(1991, 1992, 1993,2020);
  console.log(years);
  Output:- [ 1991, 1992, 1993, 2020 ]
  
console.log(friends[0]); //Micheal
console.log(years[2]);	//1993
  
  

> length 
console.log(friends.length);	//3
console.log(years.length);	//4


Scenario:-
When you don't know how many elements are there, but want to know last element-->
console.log(friends[friends.length-1]);

>We can mutate the particular index although arrays friends and years are constants.
friends[1] = "Devanshu";
console.log(friends);

> But we can not replace an entire array
const friends = ["Micheal", "Steven", "Peter"];
friends=['Bob','Alice'];	//It is illegal

> Arrays can hold different types of values at the same time
const friends = ["Micheal", "Steven", "Peter"];
const firstName = 'Jonas';
const jonas = [firstName,'Schmedtmann',2037-1991,'teacher',friends];	//So, we can include array inside array

	

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Basic Array Operations (Methods)<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

>push method--> add elements to the end

const friends = ["Micheal", "Steven", "Peter"];
friends.push('Jay');
console.log(friends);	// [ "Micheal", "Steven", "Peter", "Jay" ]

push method also return a value that is length (new length) of the array.

>unshift method ---> It joins element at the beginning. It also returns length of array.(new length)

const friends = ["Micheal", "Steven", "Peter"];
friends.unshift('John');
console.log(friends);

>pop method---> Removes last element of an array. It returns the removed element. 
const popped = friends.pop();

>shift method---> Removes the first element of an array.
friends.shift();


> indexof method--->
It tells the index of an element in an array.
console.log(friends.indexof('Steven'));
If the element is not present, it gives -1 as output.

> include method---> Gives true if element present and gives false if element is not present. 

This method tests with strict equality that means does not do type coercion.
friends.push(23);
console.log(friends.include('23'));//false


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Instroduction to Objects<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const jonasArray = [
  "Jonas",
  "Schmedtmann",
  2037 - 1991,
  ["Micheal", "Peter", "Steven"],
];

In this array, elements are referenced by order number. 

const jonas = {
  firstName: "Jonas",
  lastName: "Schedtmann",
  age: 2037 - 1991,
  friends: ["Michael", "Peter", "Steven"],
};
This is an object. 

Difference between Arrays and Objects-->
------------------------------------------
In objects, the order of values does not matter when we want to retrieve them. 
In arrays, the order of values matter. 
We should use array for more ordered data and objects for more un-structured data. 


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Dot vs Bracket Notation<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Gonna learn, how to retrieve and change data of objects using both Dot and bracket notation.

const jonas = {
  firstName: "Jonas",
  lastName: "Schedtmann",
  age: 2037 - 1991,
  friends: ["Michael", "Peter", "Steven"],
};
console.log(jonas);	//I will print the whole object as it. 


> Dot(.) Notation-->
console.log(jonas.lastName);

> Bracket Notation-->
----------------------
console.log(jonas['firstName']);
	Here, we can write any expression, we don't need to explicitly write the string here, but instead we can compute it from some operation.
	
const nameKey = 'Name';
console.log(jonas['first'+nameKey];
console.log(jonas['last'+nameKey];


> When should we use Dot notation and when should we use bracket notation
	We should use Bracket notation when we need to compute property name like we did above. 
	Another use case of Bracket notation--> 
		const interestedIn = prompt('What do you want to know about jonas, choose between firstName,lastName,age,job and friends');
		console.log(jonas.interesetedIn);		//Undefined because interestedIn property does not exists in Object jonas.
		
		console.log(jonas[interesetedIn]);	//Output--->teacher		//It will also give undefined if any property is outside the object.
		
> Another Use Case of Bracket Notation-->
if (jonas[interestedIn]) {
	console.log(jonas[interestedIn]);
}else{ 
	console.log("Wrong Request");	
}

> We can add properties in Object--->
jonas.location = 'Portugal';
jonas['twitter'] = '@jonasschmedtmann';



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Object Methods<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
					
We can add functions to objects. Any function that is attached to an object is called method. 

We write expression function, not declaration function.
const jonas = {
  firstName: "Jonas",
  lastName: "Schedtmann",
  birthYear: 2037 - 1991,
  friends: ["Michael", "Peter", "Steven"],
  calcAge: function (birthyear) {
    return 2037 - birthyear;
  },
};

console.log(jonas.calcAge(1991));	//46
console.log(jonas["calcAge"](1991));	//46


> this keyword
It refers to Object.

const jonas = {
  firstName: "Jonas",
  lastName: "Schedtmann",
  birthYear: 1991,
  friends: ["Michael", "Peter", "Steven"],
  hasDriversLicense: true,
  calcAge: function () {
    console.log(this);
    return 2037 - this.birthYear;
  },
};

console.log(jonas.calcAge());		//46
					//We could do jonas.birthyear but it is not a good practice.
					

> Now, suppose we want this age multiple times--->
console.log(jonas.calcAge());
console.log(jonas.calcAge());
console.log(jonas.calcAge());
console.log(jonas.calcAge());


const jonas = {
  firstName: "Jonas",
  lastName: "Schedtmann",
  birthYear: 1991,
  friends: ["Michael", "Peter", "Steven"],
  hasDriversLicense: true,
  calcAge: function () {
    this.age = 2037 - 1991;
  },
};

this.age will create new property age. 

jonas.calcAge();		//We need this to process the method in order to create property age.
console.log(jonas.age);		

We don't need 'return this.age' in calcAge function.



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Iterator: The for Loop<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

for(let rep=1;rep<=10;rep++){
	console.log(`Lifting weights repetition ${rep}`);
}


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Looping Arrays, Breaking and Continuing<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const jonas = [
  "Jonas",
  "Schmedtmann",
  2037 - 1991,
  "teacher",
  ["Micheal", "Peter", "Steven"],
  true,
];
for (let i = 0; i < jonas.length; i++) {
  console.log(jonas[i], typeof jonas[i]);
}



---------------------------------------

continue---> It exits the current iteration.

const jonas = [
  "Jonas",
  "Schmedtmann",
  2037 - 1991,
  "teacher",
  ["Micheal", "Peter", "Steven"],
  true,
];
console.log('ONLY STRINGS');
for (let i = 0; i < jonas.length; i++) {
  if (typeof jonas[i] !== "string") continue;
  console.log(jonas[i], typeof jonas[i]);
}

Output:-
--------------
Jonas string 
Schmedtmann string
teacher string


> break;

console.log("---BREAK WITH NUMBER---");
for (let i = 0; i < jonas.length; i++) {
  if (typeof jonas[i] === "number") break;
  console.log(jonas[i], typeof jonas[i]);
}


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Looping Backwards and loops in loops<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const jonas = [
  "Jonas",
  "Schmedtmann",
  2037 - 1991,
  "teacher",
  ["Micheal", "Peter", "Steven"],
  true,
];


> Looping Backwards--->
for (let i = jonas.length - 1; i >= 0; i--) {
  console.log(i, jonas[i]);
}


> Loop inside of a Loop--->
----------------------------
It is just simple.


> While loop
--------------
for (let rep = 1; rep <= 10; rep++) {
  console.log(`Lifting weights repetition ${rep}`);
}

Let's do it using while loop--->


let rep = 1;
while (rep <= 10) {
  console.log(`Lifting weights repetition ${rep}`);
  rep++;
}

>> Math.random()--> It will give decimal random number. Between 0 and 1. 0 is inclusive but 1 is exclusive.
````````````````````````````````````````````````````````



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>THE END<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
















